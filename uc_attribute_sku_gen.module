<?php

/**
 * Implements hook_action_info().
 *
 * This function defines all custom actions added by this module.
 */
function uc_attribute_sku_gen_action_info() {
  return array(
	'uc_attribute_sku_gen_update_option_skus_action' => array(
      'type' => 'node',
      'label' => t('Generate SKUs for all option combinations'),
      'configurable' => FALSE,
	  'aggregate' => FALSE,
    ),
  );
}

/**
 * Execute the action.
 */
function uc_attribute_sku_gen_update_option_skus_action($node, $params) {
  // make sure it's a product with attributes
  if (uc_product_is_product($node) && count($node->attributes) > 0) {
    // get base sku
    $base_sku = $node->model;

    // generate array of [aid]=>[oid] so we can do a cartesian product
    // initially, put default_ordering as main key so we can sort
    // use default_ordering so order is consistent across all products
    $aid_oid_unsorted = array();
    foreach ($node->attributes as $aid => $attribute) {
      foreach ($attribute->options as $oid => $option) {
        $aid_oid_unsorted[$attribute->default_ordering][$aid][] = "$oid"; // force oid to be string (necessary for db actions)
      }
    }

    // sort by default_ordering
    ksort($aid_oid_unsorted);

    // remove default_ordering keys now that it's sorted
    $aid_oid_sorted = array();
    foreach($aid_oid_unsorted as $aid_oid) {
      foreach($aid_oid as $aid => $oid) {
        $aid_oid_sorted[$aid] = $oid;
      }
    }

    // generate all combinations of the enabled options
    $combos = _uc_attribute_sku_gen_array_cartesian($aid_oid_sorted);

    // for each combo, create a unique sku
    foreach ($combos as $combo) {
      $error = FALSE;
      $adjustment_sku = $base_sku;

      // get sku adjustment
      $adjustment_sku .= _uc_attribute_sku_gen_gen_adjustment_sku($combo, $node->attributes);

      // create conditions for updating/inserting
      $conditions = array();
      $conditions[] = $adjustment_sku;
      $conditions[] = $node->nid;
      $conditions[] = serialize($combo);

      // db_merge?! How awesome is this! Update or Insert... depending on whether or not it exists!
      $affected = db_merge('uc_product_adjustments')
        ->key(array(
          'nid' => $node->nid,
          'combination' => serialize($combo)
        ))
        ->fields(array(
          'model' => $adjustment_sku
        ))
        ->execute();

      /*
      // Load modified node to check if operation was processed correctly.
      $new_sku_db = db_fetch_object(db_query("SELECT model FROM {uc_product_adjustments} WHERE nid = %d AND combination = '%s'", $node->nid, serialize($combo)));

      if($new_sku_db->model != $adjustment_sku) {
        drupal_set_message(t('An option combination of %node may not have updated properly, please check and update manually if needed.', array('%node' => $node->title)), 'warning');
        watchdog('Ubercart attribute sku generator', 'An option combination of %node may not have updated properly, please check and update manually if needed.', array('%node' => $node->title), WATCHDOG_WARNING, l(t('edit'), 'node/' . $node->nid . '/edit'));
      }*/
    }
  }
  else {
    drupal_set_message(t('%node may not have updated properly, please check and update manually if needed.', array('%node' => $node->title)), 'warning');
    // watchdog('Ubercart attribute sku generator', '%node may not have updated properly, please check and update manually if needed.', array('%node' => $node->title), WATCHDOG_WARNING, l(t('edit'), 'node/' . $node->nid . '/edit'));
  }
}

/**
 * Implements hook_form_alter()
 */ /*
function uc_attribute_sku_gen_form_alter(&$form, &$form_state, $form_id) {
  if ($form_id == 'uc_product_adjustments_form') {
    // print("<pre>Begin form alter stuff\n");
    // print_r($form_state);

    // get the default sku as the base
    $default_sku = $form['default']['#value'];

    foreach ($form['table']['body'] as &$combo) {
      if (is_array($combo) && isset($combo['combo_array'])) {
        // print_r($combo);
        // print_r($combo['combo_array']['value']);

        $serialized = $combo['combo_array']['#value'];
        $unserialized = unserialize($serialized);
        // print_r($unserialized);

        $sku = $combo['model']['#default_value'];
        
        if ($sku == $default_sku) {
          $combo['model']['#default_value'] .= _uc_attribute_sku_gen_gen_adjustment_sku($unserialized,$form['#parameters'][2]->attributes);

          // If we changed it, mark it on the form
          $combo['model']['#suffix'] = '*';
        }
      }
    }
  }
} */

function _uc_attribute_sku_gen_gen_adjustment_sku($combo, $attrib_opt_array) {
  $sku_adjustment = '';
  foreach ($combo as $aid => $oid) {
    $option = preg_replace("/[^A-Za-z0-9]/",'', $attrib_opt_array[$aid]->options[$oid]->name);
    $sku_adjustment .= '-' . $option;
  }
  return $sku_adjustment;
}

/*
 * Generate all possible combinations of current attribute/options enabled
 * Source: http://stackoverflow.com/a/8936492/627772
 * Note: should be rewritten for drupal?
 */
function _uc_attribute_sku_gen_array_cartesian($arrays) {
  $result = array();
  $keys = array_keys($arrays);
  $reverse_keys = array_reverse($keys);
  $size = intval(count($arrays) > 0);
  foreach ($arrays as $array) {
    $size *= count($array);
  }
  for ($i = 0; $i < $size; $i ++) {
    $result[$i] = array();
    foreach ($keys as $j) {
      $result[$i][$j] = current($arrays[$j]);
    }
    foreach ($reverse_keys as $j) {
      if (next($arrays[$j])) {
        break;
      }
      elseif (isset ($arrays[$j])) {
        reset($arrays[$j]);
      }
    }
  }
  return $result;
}