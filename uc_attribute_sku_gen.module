<?php

/**
 * Implements hook_action_info().
 *
 * This function defines all custom actions added by this module.
 */
function uc_attribute_sku_gen_action_info() {
  return array(
    'uc_attribute_sku_gen_update_option_skus_action' => array(
      'type' => 'node',
      'description' => t('Generate SKUs for all option combinations'),
      'configurable' => FALSE,
      'hooks' => array(
        'nodeapi' => array('update'),
      )
    )
  );
}

/**
 * Execute the action.
 */
function uc_attribute_sku_gen_update_option_skus_action($node, $context) {
  print("<pre>");
  print_r(uc_product_types());
  print_r($node);
  print("</pre>");
  
  $error = FALSE;
  // make sure it's a product with attributes
  if (uc_product_is_product($node) && count($node->attributes) > 0) {
    // get base sku
    $base_sku = $node->model;
    
    // load all option combinations (adjustments) from DB
    $adjustments = db_query("SELECT nid, combination, model FROM {uc_product_adjustments} WHERE nid = %d", $node->nid);

    // update each adjustment with a generated model
    // do we only want to do this if it's not equal to the base model?
    while ($adjustment = db_fetch_object($adjustments)) {
      print("<pre>");
      print_r($adjustment);
      print("</pre>");
      // $available = array();
      // $combo = unserialize($data->combination);
      // if ($data->stock || !$data->active) { // Stock is available or stock tracking is NOT active
      //  $available = array_merge($available, array_values($combo)); // Merge value into array
      //}
    }
    
    // do some magical generating in new array(?)
  }
  else {
    $error = TRUE;
  }

  if (!$error) {
    print("saving!");
    // Save modified product.
    // node_save($node);
    // Load modified node to check if operation was processed correctly.
    // $new_node = node_load($node->nid, NULL, TRUE);
  }
  if ($error /* || $new_node->attributes != $attributes */) {
    drupal_set_message(t('%node may not have updated properly, please check and update manually if needed.', array('%node' => $node->title)), 'warning');
    watchdog('Ubercart attribute sku generator', '%node may not have updated properly, please check and update manually if needed.', array('%node' => $node->title), WATCHDOG_WARNING, l(t('edit'), 'node/' . $node->nid . '/edit'));
  }
}

/**
 * Implements hook_form_alter()
 */
function uc_attribute_sku_gen_form_alter(&$form, &$form_state, $form_id) {
  if ($form_id == 'uc_product_adjustments_form') {
    // print("<pre>Begin form alter stuff\n");
    // print_r($form_state);

    // get the default sku as the base
    $default_sku = $form['default']['#value'];

    foreach ($form['table']['body'] as &$combo) {
      if (is_array($combo) && isset($combo['combo_array'])) {
        // print_r($combo);
        // print_r($combo['combo_array']['value']);

        $serialized = $combo['combo_array']['#value'];
        $unserialized = unserialize($serialized);
        // print_r($unserialized);

        $sku = $combo['model']['#default_value'];
        
        if ($sku == $default_sku) {
          // $combo['model']['#default_value'] .= '-';
          foreach ($unserialized as $aid => $oid) {
            $option = preg_replace("/[^A-Za-z0-9]/",'', $form['#parameters'][2]->attributes[$aid]->options[$oid]->name);
            $combo['model']['#default_value'] .= '-' . $option;
          }
        }
      }
    }
  }
}